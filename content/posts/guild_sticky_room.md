---
title: "子pd置顶房间卡片性能优化与重构实践"
date: 2023-07-06
draft: false
tags: ["性能优化", "安卓"]
categories: ["技术"]
---

> 介绍了子pd置顶房间近10种卡片的性能优化方案、结果数据。

# 一、背景
## 1、缘起
`子pd置顶房间卡片`(下称置顶卡片)是pd首页顶部区域核心功能之一，但是历史上多期由不同的团队参与开发，实现层次较为复杂、维护负担较重、存在较大的性能开销。订阅pd功能上线后，其在部分机型订阅pd场景，有较明显的卡顿体验，亟待梳理与优化。
## 2、挑战点
### 2.1、卡片种类多
优化前，现网共有`热聊中`、`发帖中`、`观看直播`、`探索中(近期下架)`、`语音中`、`听歌中`、`开黑中`、`互动中`、`共享中`共计**9种业务卡片（如下图所示）**与`延迟占位`1种临时技术优化占位卡片(优化后删除)。
![图片](/images/4/3cfc040b-0a31-447a-8b44-4045cc657015.png)

### 2.2、样式与业务逻辑复杂
横看成岭侧成峰，远近高低各不同——9种卡片内部样式涉及*直播推流、跑马灯、上下有限轮播列表、左右无限轮播列表、波纹头像及其列表、动态icon、封面图过渡替换*等*组件、动画*。眼花缭乱的样式进一步产生复杂的业务逻辑，要求开发者熟稔需求的每个细节。
### 2.3、多场景
涉及`消息tab订阅pd`、`pd tab首页`、`pd 独立页`**3种业务场景**（如下图所示），另外涉及各场景下**Pad适配**异化逻辑。
![图片](/images/4/97ca5f95-3533-4c4b-8245-14be767932af.png)

### 2.4、数据源复杂
由于不同的卡片源于不同的子pd业务，其数据格式混杂错乱，数据源多且复杂。比如**现网虽然整体基于`MVVM`架构做了分层，部分卡片为了拿自己额外的数据，又单独在`view`层做了异化的数据拉取、监听**。
![图片](/images/4/ddac2019-fba9-4fa9-b70c-a5b944edea7c.png)

## 3、前置调研
为了顺利地完成置顶卡片的优化，我们预先测试、分析现网实现，并调研了一些可行性方案。
- 期间主要发现以下异常
    * 每个置顶卡片都是较重的Fragment
    * 实际展示两个置顶卡片，缺创建了6个Fragment
    * 布局文件inflate时间较长
    * 卡片大于10个时，轮播过程中偶现会闪
- 期间主要涉及了以下工具、方案
    * 使用[perfetto](https://ui.perfetto.dev/)分析trace
    * 使用司内APP自动化测试框架，以方便对相同用例重复测试、对比同一事件点性能变化情况
    * 使用司内[PerfDogService](https://perfdog.qq.com)收集cpu、内存性能数据
    * 使用司内raftkit收集帧率性能数据

最终的整体思路是更改`UI`加载、渲染的调度时机，在不影响整体视觉效果的前提下尽可能延迟加载、渲染，并使用公共的缓存池减少加载频次。另外梳理并优化`View`、`ViewModel`代码层次，便于以后的维护、拓展和问题定位。

# 二、优化过程
## 1、FragmentAdapter 改为 AsyncListDifferDelegationAdapter
现网对于每个卡片，使用了 `FragmentAdapter` 。虽然这样做便于管理生命周期，但导致每个卡片都是一个`Fragment`，增加了每个卡片的负担，并可能导致难以解决的crash，如[TransactionTooLargeException]( https://iwiki.woa.com/p/4007775071)需要专人分析。

为了解决这个问题，我们将其更改为使用 `AsyncListDifferDelegationAdapter` 和普通的 `ViewHolder` 。通过在子线程中使用 `DiffUtil` 异步比较列表差异，我们能够更加高效地更新RecyclerView中的数据。DiffUtil了解更多见[DiffUtil 回调](https://km.woa.com/articles/show/582695)

## 2、无限轮播方案
在针对轮播场景的解决方案中，现网 `viewPager2`滚动方案如下：在 `adapter` 的 `getItemCount()` 方法中，返回实际数量的3倍；首次渲染时，将第 `count` 个元素作为首次展示的元素；在 `bindViewHolder` 时，对 `position` 进行3取余数操作。当滚动到 `count-1` 时，强制跳转到第 `count*2-1` 个元素；当滚动到 `2*count` 时，强制跳转到第 `count` 个元素。

以3个卡片为例，无限滚动的实现过程是依次展示...3->4->5->3->4->5->3...这些元素。在滚动和预览过程中，第2和第6个位置的卡片会被展示，但在即将真正展示时，会被强制跳转到第5和第3个位置。以此达到循环滚动的效果。
![图片](/images/4/2b230b72-bba3-4916-8909-7f86dd0cda97.png)

虽然这种实现确实可行，但由于业务逻辑过于死板，导致了一些问题：
- 以第一期为基准，业务假设最多有6个卡片，并对 `viewPager` 无脑设置了缓存6个卡片。由于采用了3倍 `count` 的逻辑，比如当置顶卡片数量为2个时，却会直接创建6个卡片用于滚动，从而产生大量多余的开销。
  ![图片](/images/4/0991d8ce-1e9d-4e4b-be15-fdff77e9d2b7.png)

- 以第一期为基准，业务假设最多有6个卡片，并对 `viewPager` 无脑设置了缓存6个卡片。然而，近几个月产品层将卡片上限调整为了20个。这导致在滑动到边界、复位时，缺少另一侧的缓存。每滑动一遍，都会触发重新创建一轮卡片。


为了解决这些问题，我们更换了实现方案，去掉了无脑缓存6个卡片的逻辑。现在， `getItemCount()` 返回 `Int.MAX_VALUE` ，在 `bindViewHolder` 时，让 `position` 对卡片实际数量取余数，并在初始时将位置设置为 `Int.MAX_VALUE/2` 。


## 3、UI 渲染调度时机优化
如下图所示，我们：
- 使用ViewStub组织背景内容，onCreate时仅创建一个空的卡片，以减少初始加载时间；实现在onCreate和onBind时延迟加载、渲染卡片内容以及设置图片资源的时机。
- 将按压动画、颜色背景、图片资源等执行，以降低对首次出现时性能的影响。
- 在订阅pd展开时，如果当前卡片不是第一个，等待订阅pd展开后再加载、渲染卡片内容，以降低对订阅pd展开动画时的资源抢占。
  ![图片](/images/4/d2c6b277-1897-41ac-9928-a118533af738.png)

通过以上优化方案，我们可以：在保证功能完整的前提下，实延迟不必要的资源加载，实现更高效的资源调度和管理，提高 `ViewHolder` 创建时流畅度。


## 4、xml2java 减少 inflate 布局资源的时间

对于布局资源，直接使用`Java`代码组织布局，时间消耗相对`LayoutInflater`解析`xml`减少约20%。这里不再赘述。

## 5、公共缓存池 RecycledViewPool

分析发现，`消息tab订阅 pd`、`pd tab首页`、`pd 独立页`3种业务场景，其**置顶卡片可以复用同一套view的缓存池**，这样可以减少卡片本身的创建次数。
![图片](/images/4/f0ce63a9-1737-463c-ae9f-96aa7beca3f8.png)

另外对于`文字子pd置顶卡片`、`帖子子pd置顶卡片`，其滚动的摘要列表也可以复用同一套view的缓存池，这样不同页面、不同卡片间复用摘要item，可以减少摘要item的创建次数。

## 6、必要时停掉卡片内部动画
具体地，在订阅pd展开、子pd列表滑动、置顶房间卡片不可见时等时机，停掉置顶房间卡片的动画（如pd icon 停掉 lottie 动画、停掉直播流、停掉文字和帖子子pd的滚动等）。

## 7、布局元素梳理，删除过度设计的小组件
原来的开发来回拷贝时，未考虑具体场景需要、遵循童子军法则，这里主要梳理了一些代码细节：
- 不需要圆角的图片，误用了`RoundImageView`。改为普通的`ImageView`。
- 一些圆角图片的实现，用`RadiusFragmeLayout`包一层的`ImageView`。直接改为`RoundImageView`。
- 下掉过度包装、冗余的 `ChanelStatusView`（`背景+LottieView+TextView`）、`JoinBtnView`（只有一个`TextView`）、`MemberCountView`(只是一个`ImageView+TextView`)等过度设计的小组件。

以`ChanelStatusView`为例，其`UI`只是简单的“`背景图+lottie+text`”，却会在初始化无谓地加载一些`Drawable`、`String`等资源并初始化大量成员，产生冗余性能开销。
![图片](/images/4/089dea31-59e3-4d26-b02e-2f3f6d9f68ec.png)

![图片](/images/4/f6d1d5a3-06f4-4c4f-9738-3fe3c3c7ca9a.png)

## 8、数据源收归
【一、2.4】提到，数据源不统一。性能优化过程中，针对此在`ViewModel`层使用`Kotlin Flow`对数据源进行了收归处理。
![图片](/images/4/1783a9a7-b355-488f-bae6-fc7c83231710.png)

## 9、过度绘制分析
优化过程中，我们以不影响视觉要求为前提，重新梳理了卡片布局，优化了一些卡片多余的层次（效果见【三、1】）。
我们也额外分析订阅pd相关场景，分析发现、推动解决了其他业务对订阅pd过度绘制的影响。

# 三、性能结果对比

## 1、过度绘制对比
**去掉了一些卡片过度绘制的层次**，以来回嵌套的背景色为主。
- 直播卡片
  ![图片](/images/4/5b3d7b86-8640-42f2-9cc1-9b14d0daed4d.png)

- 屏幕共享卡片
  ![图片](/images/4/ef24015b-33ce-4430-b6f5-2078a6dc8415.png)

## 2、GPU呈现模式分析对比

以`红米K40`（21年2月发布，骁龙870）为例，手动测试，在展开订阅pd的那一刻截图查看GPU变化。
对比发现，优化前顶峰徘徊在“导航栏蓝色气泡”附近，优化后顶峰基本在“子pd-pd公告栏”附近。**GPU呈现模式分析整体峰值、持续时间有下降**。
- 优化前
  ![图片](/images/4/c6b0a1dd-0d60-4e24-9c45-6be665bf86c4.png)

- 优化后
  ![图片](/images/4/357c8608-ccaf-42e2-aefa-e7cda156d696.png)

## 3、帧率对比
以`荣耀V40`为例，通过`UITrace`自动化测试相同用例，使用`raftkit`记录`fps`数据（不过似乎不太准，且`PerfDogService`更不准）。最终提取订阅pd展开那一秒的`fps`数据。
对比发现，**优化后同比提升了近4帧（注意订阅pd展开动画约300ms）；且方差变小，说明流畅度更为稳定**。

|case | 优化前1     | 优化前2 | 优化后1            | 优化后2 |
|:--|----------|------|-----------------|------|
|0 | xx       | xx   | xx              | xx   |
|平均帧率 | **43.1** |      | **46.9**  |      |
|方差 | **7.3**  |      | **3.9** |      |


## 4、CPU对比

以`华为Nova8Pro`为例，通过`UITrace`自动化测试相同用例，使用`PerfDogService`打点记录`cpu`数据。测试用例是来回展开、收起订阅pd10次，优化前后各测5次求平均值。

对比发现，优化后订阅pd展开时`cpu`有上升，初步分析是`x2j`的方案使`IO`吞吐加载布局文件改为动态`new`布局`binding`对象，`cpu`使用有上升。
![图片](/images/4/454ab3a2-1e0b-4109-98da-e0a79f1633cd.png)

## 5、内存对比
以`华为Nova8Pro`为例，通过`UITrace`自动化测试相同用例，使用`PerfDogService`打点记录`内存`数据。测试用例是来回展开、收起订阅pd10次，优化前后各测5次求平均值。

因为`ViewHolder`公共缓存池会在订阅pd首次后，持有一些`view`内存，我们担心引起较大的内存增量。对比发现，优化后订阅pd来回展开、收起，内存波动更大，但**收起订阅pd后同比无明显内存增量**。
![图片](/images/4/8a3ffe2c-a338-47ff-a8cd-d6746abd211b.png)

# 附注

## 1、CPU数据
![图片](/images/4/38684c80-dfb7-48e9-921d-83435c2675da.png)

## 2、内存数据
![图片](/images/4/d55f6682-730b-440f-ade6-6f91738ee271.png)

## 3、测试用例
打开xx，在消息tab来回展开、收起订阅pd10次。
![图片](/images/4/c530b439-a207-4ad3-94ff-afaa17468be1.png)


## 4、一些工具与方法链接
perfetto: https://ui.perfetto.dev/

PerfDogService: https://perfdog.qq.com/perfdogservice
